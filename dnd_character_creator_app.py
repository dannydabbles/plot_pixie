import os
import openai
import requests
import streamlit as st
import pandas as pd
from uuid import uuid4

# Set OpenAI API Key
openai.api_key = os.environ.get('OPENAI_API_KEY')

def get_character_data(character):
    """
    Query the ChatGPT API to fill out missing character data based on provided data.
    """
    prompt = f"Describe a D&D character with the following attributes: {character}"
    response = openai.Completion.create(model="text-davinci-003", prompt=prompt, max_tokens=150)
    return response.choices[0].text.strip()

def save_dalle_image_to_disk(image_url, character_name, portrait_num):
    """
    Saves the DALL·E generated image to the local disk.

    Parameters:
    - image_url: URL of the image generated by DALL·E.
    - character_name: Name of the character to be used in filename.
    - portrait_num: The number of the portrait for this character.

    Returns:
    - The path to the saved file.
    """
    # Use the requests library to fetch the image
    response = requests.get(image_url)
    response.raise_for_status()  # Raise an error for failed requests

    # Save the image to the local filesystem
    current_directory = os.getcwd()
    filename = f"{current_directory}/images/{character_name}_portrait_{portrait_num}.png"

    # Make the path
    os.makedirs(os.path.dirname(filename), exist_ok=True)

    with open(filename, "wb") as file:
        file.write(response.content)

    return filename

def generate_portrait(prompt):
    """
    Generate a portrait based on the prompt using DALL-E and save it locally.
    """
    response = openai.Image.create(prompt=prompt, n=1, size="256x256")
    image_url = response.data[0]['url']
    filename = f"portraits/{uuid4()}.png"
    return save_dalle_image_to_disk(image_url, filename, 1)

def generate_html_character_sheet(character, portrait_filenames):
    """
    Generate an HTML character sheet based on character data and save it locally.
    """
    html_content = f"""
    <h1>{character['name']}</h1>
    <p><strong>Race:</strong> {character['race']}</p>
    <p><strong>Class:</strong> {character['class']}</p>
    <p><strong>Alignment:</strong> {character['alignment']}</p>
    <p><strong>Background:</strong> {character['background']}</p>
    <p><strong>Description:</strong> {character['description']}</p>
    <p><strong>Personality Traits:</strong> {character['personality_traits']}</p>
    <p><strong>Ideals:</strong> {character['ideals']}</p>
    <p><strong>Bonds:</strong> {character['bonds']}</p>
    <p><strong>Flaws:</strong> {character['flaws']}</p>
    """
    for filename in portrait_filenames:
        html_content += f'<img src="{filename}" alt="Portrait of {character["name"]}">'

    current_directory = os.getcwd()
    filename = f"{current_directory}/character_sheets/{uuid4()}.html"

    # Make the path
    os.makedirs(os.path.dirname(filename), exist_ok=True)

    with open(filename, 'w') as file:
       file.write(html_content)
    return filename


def main():
    """
    Main function for the Streamlit app.
    """
    st.title("D&D Character Generator with Portraits")

    # Default visible fields
    character = {
        "name": st.text_input("Character Name", "Aelar"),
        "description": st.text_area("Description")
    }

    # Expander for Basic Information
    with st.expander("Basic Information"):
        character.update({
            "age": st.number_input("Age", min_value=1, max_value=500, value=25),
            "gender": st.selectbox("Gender", ["Male", "Female", "Non-Binary", "Other", "Prefer not to say"]),
            "race": st.selectbox("Race", ["Human", "Elf", "Dwarf", "Orc", "Tiefling", "Gnome", "Halfling", "Dragonborn", "Aarakocra", "Genasi", "Goliath", "Tabaxi", "Triton", "Custom"]),
            "subrace": st.text_input("Subrace (if applicable)", ""),
            "class": st.selectbox("Class", ["Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", "Ranger", "Rogue", "Sorcerer", "Warlock", "Wizard", "Custom"]),
            "alignment": st.selectbox("Alignment", ["Lawful Good", "Neutral Good", "Chaotic Good", "Lawful Neutral", "True Neutral", "Chaotic Neutral", "Lawful Evil", "Neutral Evil", "Chaotic Evil"]),
            "background": st.selectbox("Background", ["Acolyte", "Charlatan", "Criminal", "Entertainer", "Folk Hero", "Guild Artisan", "Hermit", "Noble", "Outlander", "Sage", "Sailor", "Soldier", "Urchin", "Custom"]),
        })

    # Expander for Personality & Backstory
    with st.expander("Personality & Backstory"):
        character.update({
            "personality_traits": st.text_area("Personality Traits"),
            "ideals": st.text_area("Ideals"),
            "bonds": st.text_area("Bonds"),
            "flaws": st.text_area("Flaws"),
            "character_backstory": st.text_area("Character Backstory"),
            "allies_enemies": st.text_area("Allies & Enemies"),
        })

    # Expander for Abilities & Skills
    with st.expander("Abilities & Skills"):
        character.update({
            "languages": st.multiselect("Languages", ["Common", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Orc", "Abyssal", "Celestial", "Draconic", "Deep Speech", "Infernal", "Primordial", "Sylvan", "Undercommon"]),
            "skills": st.multiselect("Skills", ["Acrobatics", "Animal Handling", "Arcana", "Athletics", "Deception", "History", "Insight", "Intimidation", "Investigation", "Medicine", "Nature", "Perception", "Performance", "Persuasion", "Religion", "Sleight of Hand", "Stealth", "Survival"]),
        })

    # Expander for Equipment & Treasures
    with st.expander("Equipment & Treasures"):
        character.update({
            "equipment": st.text_area("Starting Equipment"),
            "treasure": st.text_area("Treasure"),
        })

    # Expander for Spellcasting (if applicable)
    with st.expander("Spellcasting"):
        character.update({
            "spellcasting_class": st.text_input("Spellcasting Class", ""),
            "spellcasting_ability": st.text_input("Spellcasting Ability", ""),
            "spell_save_dc": st.text_input("Spell Save DC", ""),
            "spell_attack_bonus": st.text_input("Spell Attack Bonus", ""),
        })

    # Number of portraits
    num_portraits = st.slider("Number of Portraits", 1, 5)

    if st.button("Generate Character Sheet"):
        # Fetch filled out character data from the API
        character["description"] = get_character_data(character)

        # Generate portrait prompts and portraits
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({key: character[key] for key in ["name", "race", "class", "background"]})
            portrait_filenames.append(generate_portrait(portrait_prompt))

        # Generate HTML character sheet and save
        html_filename = generate_html_character_sheet(character, portrait_filenames)

        # Save character data as parquet
        df = pd.DataFrame([character])
        current_directory = os.getcwd()
        parquet_filename = f"{current_directory}/data/{uuid4()}.parquet"

        # Make the path
        os.makedirs(os.path.dirname(parquet_filename), exist_ok=True)

        df.to_parquet(parquet_filename)

        # Redirect to the HTML character sheet
        st.write(f"Character sheet saved at {html_filename} and data saved at {parquet_filename}")
        st.markdown(f"[Click here to view the character sheet]({html_filename})")

        # Render the HTML character sheet
        with open(html_filename, 'r') as file:
            st.components.v1.html(file.read(), height=1000)

if __name__ == "__main__":
    main()
