import os
import openai
import streamlit as st
import pandas as pd
import requests
from uuid import uuid4

# Set OpenAI API Key
openai.api_key = os.environ.get('OPENAI_API_KEY')

# Constants
CURRENT_DIRECTORY = os.getcwd()
IMAGE_DIRECTORY = f"{CURRENT_DIRECTORY}/images/"
CHARACTER_SHEET_DIRECTORY = f"{CURRENT_DIRECTORY}/character_sheets/"
DATA_DIRECTORY = f"{CURRENT_DIRECTORY}/data/"

# Ensure directories exist
os.makedirs(IMAGE_DIRECTORY, exist_ok=True)
os.makedirs(CHARACTER_SHEET_DIRECTORY, exist_ok=True)
os.makedirs(DATA_DIRECTORY, exist_ok=True)

def get_character_data(character):
    """
    Query the ChatGPT API to fill out missing character data based on provided data.
    
    Args:
    - character (dict): Dictionary containing character attributes.

    Returns:
    - str: Generated character description.
    """
    prompt = f"Describe a D&D character with the following attributes: {character}"
    response = openai.Completion.create(model="text-davinci-003", prompt=prompt, max_tokens=150)
    return response.choices[0].text.strip()

def save_dalle_image_to_disk(image_url, character_name, portrait_num):
    """
    Saves the DALLÂ·E generated image to the local disk.

    Args:
    - image_url (str): URL of the image generated by DALLÂ·E.
    - character_name (str): Name of the character to be used in filename.
    - portrait_num (int): The number of the portrait for this character.

    Returns:
    - str: The path to the saved file.
    """
    response = requests.get(image_url)
    response.raise_for_status()  # Raise an error for failed requests
    
    filename = f"{IMAGE_DIRECTORY}{character_name}_portrait_{portrait_num}.png"
    with open(filename, "wb") as file:
        file.write(response.content)
    return filename

def generate_portrait(prompt):
    """
    Generate a portrait based on the prompt using DALL-E and save it locally.
    
    Args:
    - prompt (str): The prompt for DALL-E to generate an image.

    Returns:
    - str: Filepath where the portrait is saved.
    """
    response = openai.Image.create(prompt=prompt, n=1, size="256x256")
    image_url = response.data[0]['url']
    filename = f"{uuid4()}.png"
    return save_dalle_image_to_disk(image_url, filename, 1)

def generate_html_character_sheet(character, portrait_filenames):
    """
    Generate an HTML character sheet based on character data and save it locally.

    Args:
    - character (dict): Dictionary containing character attributes.
    - portrait_filenames (list): List of portrait filenames for the character.

    Returns:
    - str: The path to the saved HTML file.
    """
    html_content = f"""
    <h1>{character['name']}</h1>
    <p><strong>Race:</strong> {character['race']}</p>
    <!-- ... Other attributes ... -->
    """
    for filename in portrait_filenames:
        html_content += f'<img src="{filename}" alt="Portrait of {character["name"]}">'
    
    filename = f"{CHARACTER_SHEET_DIRECTORY}{uuid4()}.html"
    with open(filename, 'w') as file:
       file.write(html_content)
    return filename

def input_basic_information(character_data):
    """
    Gather basic information about the character from the user.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing basic character information.
    """
    with st.expander("Basic Information"):
        race_options = ["Human", "Elf", "Dwarf", "Orc", "Tiefling", "Gnome", "Halfling", "Dragonborn", "Aarakocra", "Genasi", "Goliath", "Tabaxi", "Triton", "Custom"]
        class_options = ["Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", "Ranger", "Rogue", "Sorcerer", "Warlock", "Wizard", "Custom"]
        alignment_options = ["Lawful Good", "Neutral Good", "Chaotic Good", "Lawful Neutral", "True Neutral", "Chaotic Neutral", "Lawful Evil", "Neutral Evil", "Chaotic Evil"]
        background_options = ["Acolyte", "Charlatan", "Criminal", "Entertainer", "Folk Hero", "Guild Artisan", "Hermit", "Noble", "Outlander", "Sage", "Sailor", "Soldier", "Urchin", "Custom"]
        
        race = st.selectbox("Race", race_options)
        if race == "Custom":
            race = st.text_input("Custom Race", character_data.get("race", ""))
        
        char_class = st.selectbox("Class", class_options)
        if char_class == "Custom":
            char_class = st.text_input("Custom Class", character_data.get("class", ""))
        
        alignment = st.selectbox("Alignment", alignment_options)
        background = st.selectbox("Background", background_options)
        if background == "Custom":
            background = st.text_input("Custom Background", character_data.get("background", ""))
        
        return {
            "age": st.number_input("Age", min_value=1, max_value=500, step=1, value=int(character_data.get("age", 25) or "25")),
            "race": race,
            "class": char_class,
            "alignment": alignment,
            "background": background
        }

def input_personality_and_backstory(character_data):
    """
    Gather information about the character's personality and backstory.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's personality and backstory.
    """
    with st.expander("Personality & Backstory"):
        return {
            "personality_traits": st.text_area("Personality Traits", character_data.get("personality_traits", "")),
            "ideals": st.text_area("Ideals", character_data.get("ideals", "")),
            "bonds": st.text_area("Bonds", character_data.get("bonds", "")),
            "flaws": st.text_area("Flaws", character_data.get("flaws", "")),
            "character_backstory": st.text_area("Character Backstory", character_data.get("character_backstory", "")),
            "allies_enemies": st.text_area("Allies & Enemies", character_data.get("allies_enemies", ""))
        }

def input_abilities_and_skills(character_data):
    """
    Gather information about the character's abilities and skills.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's abilities and skills.
    """
    with st.expander("Abilities & Skills"):
        languages_options = ["Common", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Orc", 
                             "Abyssal", "Celestial", "Draconic", "Deep Speech", "Infernal", "Primordial", 
                             "Sylvan", "Undercommon", "Custom"]
        
        languages = st.multiselect("Languages", languages_options, default=character_data.get("languages", []))
        if "Custom" in languages:
            custom_language = st.text_input("Specify the custom language", character_data.get("custom_language", ""))
            languages.append(custom_language)
            languages.remove("Custom")

        skills_options = ["Acrobatics", "Animal Handling", "Arcana", "Athletics", "Deception", "History", 
                          "Insight", "Intimidation", "Investigation", "Medicine", "Nature", "Perception", 
                          "Performance", "Persuasion", "Religion", "Sleight of Hand", "Stealth", "Survival", "Custom"]
        
        skills = st.multiselect("Skills", skills_options, default=character_data.get("skills", []))
        if "Custom" in skills:
            custom_skill = st.text_input("Specify the custom skill", character_data.get("custom_skill", ""))
            skills.append(custom_skill)
            skills.remove("Custom")
        
        return {
            "languages": languages,
            "skills": skills,
            "custom_language": custom_language if "Custom" in character_data.get("languages", []) else "",
            "custom_skill": custom_skill if "Custom" in character_data.get("skills", []) else ""
        }

def input_equipment_and_treasures(character_data):
    """
    Gather information about the character's equipment and treasures.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's equipment and treasures.
    """
    with st.expander("Equipment & Treasures"):
        return {
            "equipment": st.text_area("Starting Equipment", character_data.get("equipment", "")),
            "treasure": st.text_area("Treasure", character_data.get("treasure", "")),
            "custom_equipment": st.text_input("Custom Equipment (if any)", character_data.get("custom_equipment", "")),
            "custom_treasure": st.text_input("Custom Treasure (if any)", character_data.get("custom_treasure", ""))
        }

def input_spellcasting(character_data):
    """
    Gather information about the character's spellcasting abilities.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's spellcasting information.
    """
    with st.expander("Spellcasting"):
        spellcasting_class_options = ["Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", 
                                      "Ranger", "Rogue", "Sorcerer", "Warlock", "Wizard", "Custom"]
        
        spellcasting_class = st.selectbox("Spellcasting Class", spellcasting_class_options, index=spellcasting_class_options.index(character_data.get("spellcasting_class", "Barbarian")))
        if spellcasting_class == "Custom":
            spellcasting_class = st.text_input("Specify the custom spellcasting class", character_data.get("custom_spellcasting_class", ""))
        
        return {
            "spellcasting_class": spellcasting_class,
            "spellcasting_ability": st.text_input("Spellcasting Ability", character_data.get("spellcasting_ability", "")),
            "spell_save_dc": st.text_input("Spell Save DC", character_data.get("spell_save_dc", "")),
            "spell_attack_bonus": st.text_input("Spell Attack Bonus", character_data.get("spell_attack_bonus", ""))
        }

def generate_and_display_character_sheet(character):
    """
    Generate the character sheet, save the data, and display it to the user.
    
    Args:
    - character (dict): Dictionary containing all character attributes.
    """
    if st.button("Generate Character Sheet"):
        # Fetch filled out character data from the API
        character["description"] = get_character_data(character)

        # Generate portrait prompts and portraits
        num_portraits = st.slider("Number of Portraits", 1, 5)
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({
                key: character[key] for key in ["name", "race", "class", "background"]
            })
            portrait_filenames.append(generate_portrait(portrait_prompt))

        # Generate HTML character sheet and save
        html_filename = generate_html_character_sheet(character, portrait_filenames)

        # Save character data as parquet
        df = pd.DataFrame([character])
        parquet_filename = f"{DATA_DIRECTORY}{uuid4()}.parquet"
        df.to_parquet(parquet_filename)

        # Display the information to the user
        st.write(f"Character sheet saved at {html_filename} and data saved at {parquet_filename}")
        st.markdown(f"[Click here to view the character sheet]({html_filename})")

        # Render the HTML character sheet
        with open(html_filename, 'r') as file:
            st.components.v1.html(file.read(), height=1000)

def transform_to_dict(data_str):
    """
    Transform the provided data string into a dictionary.

    Args:
    - data_str (str): The string containing "key: value" pairs separated by newlines.

    Returns:
    - dict: The transformed dictionary.
    """
    data_dict = {}
    lines = data_str.split("\n")  # Split the string by newline to get individual lines
    for line in lines:
        if ": " in line:
            key, value = line.split(": ", 1)  # Split each line into key and value
            data_dict[key.strip()] = value.strip()  # Strip any leading/trailing whitespace and add to the dictionary

    return data_dict

def main():
    """
    Main function for the Streamlit app.
    """
    st.set_page_config(page_title="D&D Character Creator", page_icon="ðŸ“ˆ")
    st.markdown("# D&D Character Creator")
    
    character = {}

    user_input_character = {
        "name": "",
        "description": "",
        "race": "",
        "class": "",
        "alignment": "",
        "background": "",
        "age": "",
        "gender": "",
        "subrace": "",
    }

    # Fetch filled out character data from the API
    generated_data = get_character_data(user_input_character)
    #import ipdb; ipdb.set_trace()
    character_data = transform_to_dict(generated_data)
 
    # Combine the user's input and the generated data
    character.update(user_input_character)
    character.update(character_data)

    character_name = st.text_input("Character Name", character_data.get("name", ""))
    character.update({"name": character_name})
    character_description = st.text_area("Description", character_data.get("description", ""))
    character.update({"description": character_description})
 

    # Use the updated character data as defaults for the input functions
    character.update(input_basic_information(character))
    character.update(input_personality_and_backstory(character))
    character.update(input_abilities_and_skills(character))
    character.update(input_equipment_and_treasures(character))
    character.update(input_spellcasting(character))

    if st.button("Generate Character Sheet"):
        # Fetch filled out character data from the API
        character["description"] = get_character_data(character)

        # Generate portrait prompts and portraits
        num_portraits = st.slider("Number of Portraits", 1, 5)
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({
                key: character[key] for key in ["name", "race", "class", "background"]
            })
            portrait_filenames.append(generate_portrait(portrait_prompt))

        # Generate HTML character sheet and save
        html_filename = generate_html_character_sheet(character, portrait_filenames)

        # Save character data as parquet
        df = pd.DataFrame([character])
        parquet_filename = f"{DATA_DIRECTORY}{uuid4()}.parquet"
        df.to_parquet(parquet_filename)

        # Display the information to the user
        st.write(f"Character sheet saved at {html_filename} and data saved at {parquet_filename}")
        st.markdown(f"[Click here to view the character sheet]({html_filename})")

        # Render the HTML character sheet
        with open(html_filename, 'r') as file:
            st.components.v1.html(file.read(), height=1000)

if __name__ == "__main__":
    main()
