import os
import json
import uuid
import openai
import streamlit as st
import pandas as pd
import requests
from uuid import uuid4

# Set OpenAI API Key
openai.api_key = os.environ.get('OPENAI_API_KEY')

# Constants
CURRENT_DIRECTORY = os.getcwd()
IMAGE_DIRECTORY = f"{CURRENT_DIRECTORY}/images/"
CHARACTER_SHEET_DIRECTORY = f"{CURRENT_DIRECTORY}/character_sheets/"
DATA_DIRECTORY = f"{CURRENT_DIRECTORY}/data/"
MAX_TOKENS = 1500

# Ensure directories exist
os.makedirs(IMAGE_DIRECTORY, exist_ok=True)
os.makedirs(CHARACTER_SHEET_DIRECTORY, exist_ok=True)
os.makedirs(DATA_DIRECTORY, exist_ok=True)

def get_character_data(character):
    """
    Query the ChatGPT API to fill out missing character data based on provided data.
    
    Args:
    - character (dict): Dictionary containing character attributes.

    Returns:
    - str: Generated character description.
    """
    #prompt = f"Describe a D&D character with the following attributes.  Use propert JSON formatting and follow the source object's layout. Generate content for any empty fields.\n\n{json.dumps(character)}"
    #print(f"Prompt: {prompt}")
    examples = [
       {
  "name": "Liora Moonshadow",
  "description": "A graceful elf with silver hair and piercing blue eyes, adept in the arcane arts and carrying the wisdom of the ages.",
  "age": 124,
  "race": "High Elf",
  "class": "Wizard",
  "alignment": "Neutral",
  "background": "Sage",
  "personality_traits": "I am lost in thought, often oblivious to my surroundings. I'm fascinated by ancient artifacts and the secrets they hold.",
  "ideals": "Knowledge. The pursuit of knowledge is the greatest endeavor.",
  "bonds": "I am on a quest to find an ancient spellbook said to contain the secrets of the universe.",
  "flaws": "I often overlook immediate dangers, being too engrossed in my studies or thoughts.",
  "character_backstory": "Liora hails from the ancient city of Ellyndor. Trained in the Grand Library, she became obsessed with a lost spellbook of immense power. Now she travels the land in search of this artifact, using her magic to uncover hidden truths.",
  "allies_enemies": "Allied with the Keepers of the Grand Library. Beware of the Dark Enchantress, who also seeks the spellbook.",
  "languages": ["Common", "Elvish", "Draconic", "Sylvan"],
  "skills": ["Arcana", "History"],
  "custom_language": "Ancient High Elvish",
  "custom_skill": "Magical artifact identification",
  "equipment": "Staff of the Arcane, robes of the enlightened, spellbook, and a pouch of spell components",
  "treasure": "A crystal orb said to have been touched by the first wizards",
  "custom_equipment": "Silver circlet that enhances focus",
  "custom_treasure": "A shard from the Mirror of Fates",
  "spellcasting_class": "Wizard",
  "spellcasting_ability": "Intelligence",
  "spell_save_dc": "16",
  "spell_attack_bonus": "+8"
} 
    ]
    messages=[
        {"role": "system", "content": "You are a helpful dungeon master's assistant. You are helping a user fill in their D&D character sheet."},
        {"role": "system", "content": f"Here are some example character sheets:\n\n{examples}"},
        {"role": "system", "content": "The user will provide an incomplete JSON character sheet. Your job will be to fill it out completely. Feel free to take artistic licence with all character details, but make sure the character sheet is consistent and the character is playable."},
        {"role": "user", "content": f"{json.dumps(character)}"},
        {"role": "system", "content": "Please completely fill in the JSON data for the character sheet based on the provided character sheet. Use proper JSON formatting for your response.  Don't leave any values blank."},
    ]
    print(f"Messages: {messages}")
    response = openai.ChatCompletion.create(model="gpt-3.5-turbo", messages=messages, max_tokens=MAX_TOKENS)
    #import ipdb; ipdb.set_trace()
    result = response.choices[0].message.content
    print(f"Result: {result}")
    return result

def save_dalle_image_to_disk(image_url, character_name, portrait_num):
    """
    Saves the DALLÂ·E generated image to the local disk.

    Args:
    - image_url (str): URL of the image generated by DALLÂ·E.
    - character_name (str): Name of the character to be used in filename.
    - portrait_num (int): The number of the portrait for this character.

    Returns:
    - str: The path to the saved file.
    """
    response = requests.get(image_url)
    response.raise_for_status()  # Raise an error for failed requests
    
    filename = f"{IMAGE_DIRECTORY}{character_name}_portrait_{portrait_num}.png"
    with open(filename, "wb") as file:
        file.write(response.content)
    return filename

def generate_portrait(prompt):
    """
    Generate a portrait based on the prompt using DALL-E and save it locally.
    
    Args:
    - prompt (str): The prompt for DALL-E to generate an image.

    Returns:
    - str: Filepath where the portrait is saved.
    """
    response = openai.Image.create(prompt=prompt, n=1, size="256x256")
    image_url = response.data[0]['url']
    filename = f"{uuid4()}.png"
    return save_dalle_image_to_disk(image_url, filename, 1)

def generate_html_character_sheet(character, portrait_filenames):
    """
    Generate an HTML character sheet based on character data and save it locally.

    Args:
    - character (dict): Dictionary containing character attributes.
    - portrait_filenames (list): List of portrait filenames for the character.

    Returns:
    - str: The path to the saved HTML file.
    """
    html_content = f"""
    <h1>{character['name']}</h1>
    <p><strong>Race:</strong> {character['race']}</p>
    <!-- ... Other attributes ... -->
    """
    for filename in portrait_filenames:
        html_content += f'<img src="{filename}" alt="Portrait of {character["name"]}">'
    
    filename = f"{CHARACTER_SHEET_DIRECTORY}{uuid4()}.html"
    with open(filename, 'w') as file:
       file.write(html_content)
    return filename

def input_basic_information(placeholder, character_data):
    """
    Gather basic information about the character from the user.
    
    Args:
    - placeholder (streamlit.delta_generator.DeltaGenerator): Streamlit container for the section.
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing basic character information.
    """
    with placeholder.expander("Basic Information"):
        race_options = ["Human", "Elf", "Dwarf", "Orc", "Tiefling", "Gnome", "Halfling", "Dragonborn", "Aarakocra", "Genasi", "Goliath", "Tabaxi", "Triton", "Custom"]
        class_options = ["Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", "Ranger", "Rogue", "Sorcerer", "Warlock", "Wizard", "Custom"]
        alignment_options = ["Lawful Good", "Neutral Good", "Chaotic Good", "Lawful Neutral", "True Neutral", "Chaotic Neutral", "Lawful Evil", "Neutral Evil", "Chaotic Evil"]
        background_options = ["Acolyte", "Charlatan", "Criminal", "Entertainer", "Folk Hero", "Guild Artisan", "Hermit", "Noble", "Outlander", "Sage", "Sailor", "Soldier", "Urchin", "Custom"]
        
        race_key = "race_select_" + str(uuid.uuid4())  # Unique key for the race selectbox
        class_key = "class_select_" + str(uuid.uuid4())  # Unique key for the class selectbox
        alignment_key = "alignment_select_" + str(uuid.uuid4())  # Unique key for the alignment selectbox
        background_key = "background_select_" + str(uuid.uuid4())  # Unique key for the background selectbox
        age_key = "age_input_" + str(uuid.uuid4())  # Unique key for the age input
        custom_race_key = "custom_race_input_" + str(uuid.uuid4())  # Unique key for the custom race input
        custom_class_key = "custom_class_input_" + str(uuid.uuid4())  # Unique key for the custom class input
        custom_background_key = "custom_background_input_" + str(uuid.uuid4())  # Unique key for the custom background input
        
        race = st.selectbox("Race", race_options, key=race_key)
        if race == "Custom":
            race = st.text_input("Custom Race", character_data.get("race", ""), key=custom_race_key)
        
        char_class = st.selectbox("Class", class_options, key=class_key)
        if char_class == "Custom":
            char_class = st.text_input("Custom Class", character_data.get("class", ""), key=custom_class_key)
        
        alignment = st.selectbox("Alignment", alignment_options, key=alignment_key)
        background = st.selectbox("Background", background_options, key=background_key)
        if background == "Custom":
            background = st.text_input("Custom Background", character_data.get("background", ""), key=custom_background_key)
        
        age = st.number_input("Age", min_value=1, max_value=500, step=1, value=int(character_data.get("age", 25) or "25"), key=age_key)

        return {
            "age": age,
            "race": race,
            "class": char_class,
            "alignment": alignment,
            "background": background
        }

def input_personality_and_backstory(placeholder, character_data):
    """
    Gather information about the character's personality and backstory.
    
    Args:
    - placeholder (streamlit.delta_generator.DeltaGenerator): Streamlit container for the section.
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's personality and backstory.
    """
    with placeholder.expander("Personality & Backstory"):
        personality_traits_key = "personality_traits_textarea_" + str(uuid.uuid4())
        ideals_key = "ideals_textarea_" + str(uuid.uuid4())
        bonds_key = "bonds_textarea_" + str(uuid.uuid4())
        flaws_key = "flaws_textarea_" + str(uuid.uuid4())
        character_backstory_key = "character_backstory_textarea_" + str(uuid.uuid4())
        allies_enemies_key = "allies_enemies_textarea_" + str(uuid.uuid4())
        
        personality_traits = st.text_area("Personality Traits", character_data.get("personality_traits", ""), key=personality_traits_key)
        ideals = st.text_area("Ideals", character_data.get("ideals", ""), key=ideals_key)
        bonds = st.text_area("Bonds", character_data.get("bonds", ""), key=bonds_key)
        flaws = st.text_area("Flaws", character_data.get("flaws", ""), key=flaws_key)
        character_backstory = st.text_area("Character Backstory", character_data.get("character_backstory", ""), key=character_backstory_key)
        allies_enemies = st.text_area("Allies & Enemies", character_data.get("allies_enemies", ""), key=allies_enemies_key)

        return {
            "personality_traits": personality_traits,
            "ideals": ideals,
            "bonds": bonds,
            "flaws": flaws,
            "character_backstory": character_backstory,
            "allies_enemies": allies_enemies
        }

def input_abilities_and_skills(placeholder, character_data):
    """
    Gather information about the character's abilities and skills.
    
    Args:
    - placeholder (streamlit.delta_generator.DeltaGenerator): Streamlit container for the section.
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's abilities and skills.
    """
    with placeholder.expander("Abilities & Skills"):
        languages_options_key = "languages_multiselect_" + str(uuid.uuid4())
        custom_language_key = "custom_language_input_" + str(uuid.uuid4())
        skills_options_key = "skills_multiselect_" + str(uuid.uuid4())
        custom_skill_key = "custom_skill_input_" + str(uuid.uuid4())
        
        languages_options = ["Common", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Orc", 
                             "Abyssal", "Celestial", "Draconic", "Deep Speech", "Infernal", "Primordial", 
                             "Sylvan", "Undercommon", "Custom"]
        
        languages = st.multiselect("Languages", languages_options, default=character_data.get("languages", []), key=languages_options_key)
        if "Custom" in languages:
            custom_language = st.text_input("Specify the custom language", character_data.get("custom_language", ""), key=custom_language_key)
            languages.append(custom_language)
            languages.remove("Custom")

        skills_options = ["Acrobatics", "Animal Handling", "Arcana", "Athletics", "Deception", "History", 
                          "Insight", "Intimidation", "Investigation", "Medicine", "Nature", "Perception", 
                          "Performance", "Persuasion", "Religion", "Sleight of Hand", "Stealth", "Survival", "Custom"]
        
        skills = st.multiselect("Skills", skills_options, default=character_data.get("skills", []), key=skills_options_key)
        if "Custom" in skills:
            custom_skill = st.text_input("Specify the custom skill", character_data.get("custom_skill", ""), key=custom_skill_key)
            skills.append(custom_skill)
            skills.remove("Custom")
        
        return {
            "languages": languages,
            "skills": skills,
            "custom_language": custom_language if "Custom" in character_data.get("languages", []) else "",
            "custom_skill": custom_skill if "Custom" in character_data.get("skills", []) else ""
        }

def input_equipment_and_treasures(placeholder, character_data):
    """
    Gather information about the character's equipment and treasures.
    
    Args:
    - placeholder (streamlit.delta_generator.DeltaGenerator): Streamlit container for the section.
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's equipment and treasures.
    """
    with placeholder.expander("Equipment & Treasures"):
        equipment_key = "equipment_textarea_" + str(uuid.uuid4())
        treasure_key = "treasure_textarea_" + str(uuid.uuid4())
        custom_equipment_key = "custom_equipment_input_" + str(uuid.uuid4())
        custom_treasure_key = "custom_treasure_input_" + str(uuid.uuid4())
        
        equipment = st.text_area("Starting Equipment", character_data.get("equipment", ""), key=equipment_key)
        treasure = st.text_area("Treasure", character_data.get("treasure", ""), key=treasure_key)
        custom_equipment = st.text_input("Custom Equipment (if any)", character_data.get("custom_equipment", ""), key=custom_equipment_key)
        custom_treasure = st.text_input("Custom Treasure (if any)", character_data.get("custom_treasure", ""), key=custom_treasure_key)

        return {
            "equipment": equipment,
            "treasure": treasure,
            "custom_equipment": custom_equipment,
            "custom_treasure": custom_treasure
        }

def input_spellcasting(placeholder, character_data):
    """
    Gather information about the character's spellcasting abilities.
    
    Args:
    - placeholder (streamlit.delta_generator.DeltaGenerator): Streamlit container for the section.
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's spellcasting information.
    """
    with placeholder.expander("Spellcasting"):
        spellcasting_class_key = "spellcasting_class_select_" + str(uuid.uuid4())
        custom_spellcasting_class_key = "custom_spellcasting_class_input_" + str(uuid.uuid4())
        spellcasting_ability_key = "spellcasting_ability_input_" + str(uuid.uuid4())
        spell_save_dc_key = "spell_save_dc_input_" + str(uuid.uuid4())
        spell_attack_bonus_key = "spell_attack_bonus_input_" + str(uuid.uuid4())
        
        spellcasting_class_options = ["Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", 
                                      "Ranger", "Rogue", "Sorcerer", "Warlock", "Wizard", "Custom"]
        
        spellcasting_class = st.selectbox("Spellcasting Class", spellcasting_class_options, key=spellcasting_class_key)
        if spellcasting_class == "Custom":
            spellcasting_class = st.text_input("Specify the custom spellcasting class", character_data.get("custom_spellcasting_class", ""), key=custom_spellcasting_class_key)
        
        spellcasting_ability = st.text_input("Spellcasting Ability", character_data.get("spellcasting_ability", ""), key=spellcasting_ability_key)
        spell_save_dc = st.text_input("Spell Save DC", character_data.get("spell_save_dc", ""), key=spell_save_dc_key)
        spell_attack_bonus = st.text_input("Spell Attack Bonus", character_data.get("spell_attack_bonus", ""), key=spell_attack_bonus_key)

        return {
            "spellcasting_class": spellcasting_class,
            "spellcasting_ability": spellcasting_ability,
            "spell_save_dc": spell_save_dc,
            "spell_attack_bonus": spell_attack_bonus
        }

def generate_and_display_character_sheet(character):
    """
    Generate the character sheet, save the data, and display it to the user.
    
    Args:
    - character (dict): Dictionary containing all character attributes.
    """
    if st.button("Generate Character Sheet"):
        # Fetch filled out character data from the API
        character["description"] = get_character_data(character)

        # Generate portrait prompts and portraits
        num_portraits = st.slider("Number of Portraits", 1, 5)
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({
                key: character[key] for key in ["name", "race", "class", "background"]
            })
            portrait_filenames.append(generate_portrait(portrait_prompt))

        # Generate HTML character sheet and save
        html_filename = generate_html_character_sheet(character, portrait_filenames)

        # Save character data as parquet
        df = pd.DataFrame([character])
        parquet_filename = f"{DATA_DIRECTORY}{uuid4()}.parquet"
        df.to_parquet(parquet_filename)

        # Display the information to the user
        st.write(f"Character sheet saved at {html_filename} and data saved at {parquet_filename}")
        st.markdown(f"[Click here to view the character sheet]({html_filename})")

        # Render the HTML character sheet
        with open(html_filename, 'r') as file:
            st.components.v1.html(file.read(), height=1000)

def transform_to_dict(data_str):
    """
    Transform the provided data string into a dictionary.

    Args:
    - data_str (str): The string containing "key: value" pairs separated by newlines.

    Returns:
    - dict: The transformed dictionary.
    """
    print(f"Data string: {data_str}")
    #import ipdb; ipdb.set_trace()
    data_dict = json.loads(data_str)  # Convert the string to a dictionary
    return data_dict

# Set the page configuration at the very top of the script
st.set_page_config(page_title="D&D Character Creator", page_icon="ðŸ“ˆ")

# Placeholders for all user inputs
placeholders = {
    "name": st.empty(),
    "description": st.empty(),
    "basic_information": st.empty(),
    "personality_and_backstory": st.empty(),
    "abilities_and_skills": st.empty(),
    "equipment_and_treasures": st.empty(),
    "spellcasting": st.empty()
}

# Placeholders for the generated sections
character_placeholder = st.empty()
portrait_placeholder = st.empty()
save_button_placeholder = st.empty()


def main():
    """
    Main function for the Streamlit app.
    """
    st.markdown("# D&D Character Creator")
    
    character = {}

    # Initial user input using placeholders
    user_input_character = {
        "name": placeholders["name"].text_input("Character Name", ""),
        "description": placeholders["description"].text_area("Description", "")
    }

    # Collect user's input for the other sections
    user_input_character.update(input_basic_information(placeholders["basic_information"], user_input_character))
    user_input_character.update(input_personality_and_backstory(placeholders["personality_and_backstory"], user_input_character))
    user_input_character.update(input_abilities_and_skills(placeholders["abilities_and_skills"], user_input_character))
    user_input_character.update(input_equipment_and_treasures(placeholders["equipment_and_treasures"], user_input_character))
    user_input_character.update(input_spellcasting(placeholders["spellcasting"], user_input_character))
    
    character.update(user_input_character)

    # Check if user wants to generate a character sheet
    if st.button("Generate Character Sheet"):
        # Fetch filled out character data from the API
        generated_data = get_character_data(character)
        character_data = transform_to_dict(generated_data)
        character.update(character_data)

        # Update placeholders with generated data
        placeholders["name"].text_input("Character Name", character['name'])
        placeholders["description"].text_area("Description", character['description'])
        input_basic_information(placeholders["basic_information"], character)
        input_personality_and_backstory(placeholders["personality_and_backstory"], character)
        input_abilities_and_skills(placeholders["abilities_and_skills"], character)
        input_equipment_and_treasures(placeholders["equipment_and_treasures"], character)
        input_spellcasting(placeholders["spellcasting"], character)
        
        # Generate portrait prompts and portraits
        num_portraits = st.slider("Number of Portraits", 1, 5)
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({
                key: character[key] for key in ["name", "race", "class", "background"]
            })
            portrait_filenames.append(generate_portrait(portrait_prompt))
        for filename in portrait_filenames:
            portrait_placeholder.image(filename, caption=f"Portrait of {character['name']}", use_column_width=True)

    # Check if user wants to save the character sheet and portraits
    if save_button_placeholder.button("Save Character and Portraits"):        # Generate portrait prompts and portraits
        num_portraits = st.slider("Number of Portraits", 1, 5)
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({
                key: character[key] for key in ["name", "race", "class", "background"]
            })
            portrait_filenames.append(generate_portrait(portrait_prompt))

        # Generate HTML character sheet and save
        html_filename = generate_html_character_sheet(character, portrait_filenames)

        # Save character data as parquet
        df = pd.DataFrame([character])
        parquet_filename = f"{DATA_DIRECTORY}{uuid4()}.parquet"
        df.to_parquet(parquet_filename)

        # Display the saved locations to the user
        st.write(f"Character sheet saved at {html_filename} and data saved at {parquet_filename}")
        st.markdown(f"[Click here to view the character sheet]({html_filename})")

if __name__ == "__main__":
    main()
