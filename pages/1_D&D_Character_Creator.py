import os
import json
import openai
import streamlit as st
import pandas as pd
import requests
from uuid import uuid4

# Set OpenAI API Key
openai.api_key = os.environ.get('OPENAI_API_KEY')

# Constants
CURRENT_DIRECTORY = os.getcwd()
IMAGE_DIRECTORY = f"{CURRENT_DIRECTORY}/images/"
CHARACTER_SHEET_DIRECTORY = f"{CURRENT_DIRECTORY}/character_sheets/"
DATA_DIRECTORY = f"{CURRENT_DIRECTORY}/data/"
MAX_TOKENS = 1500

# Ensure directories exist
os.makedirs(IMAGE_DIRECTORY, exist_ok=True)
os.makedirs(CHARACTER_SHEET_DIRECTORY, exist_ok=True)
os.makedirs(DATA_DIRECTORY, exist_ok=True)

def get_character_data(character):
    """
    Query the ChatGPT API to fill out missing character data based on provided data.
    
    Args:
    - character (dict): Dictionary containing character attributes.

    Returns:
    - str: Generated character description.
    """
    #prompt = f"Describe a D&D character with the following attributes.  Use propert JSON formatting and follow the source object's layout. Generate content for any empty fields.\n\n{json.dumps(character)}"
    #print(f"Prompt: {prompt}")
    examples = [
       {
  "name": "Liora Moonshadow",
  "description": "A graceful elf with silver hair and piercing blue eyes, adept in the arcane arts and carrying the wisdom of the ages.",
  "age": 124,
  "race": "High Elf",
  "class": "Wizard",
  "alignment": "Neutral",
  "background": "Sage",
  "personality_traits": "I am lost in thought, often oblivious to my surroundings. I'm fascinated by ancient artifacts and the secrets they hold.",
  "ideals": "Knowledge. The pursuit of knowledge is the greatest endeavor.",
  "bonds": "I am on a quest to find an ancient spellbook said to contain the secrets of the universe.",
  "flaws": "I often overlook immediate dangers, being too engrossed in my studies or thoughts.",
  "character_backstory": "Liora hails from the ancient city of Ellyndor. Trained in the Grand Library, she became obsessed with a lost spellbook of immense power. Now she travels the land in search of this artifact, using her magic to uncover hidden truths.",
  "allies_enemies": "Allied with the Keepers of the Grand Library. Beware of the Dark Enchantress, who also seeks the spellbook.",
  "languages": ["Common", "Elvish", "Draconic", "Sylvan"],
  "skills": ["Arcana", "History"],
  "custom_language": "Ancient High Elvish",
  "custom_skill": "Magical artifact identification",
  "equipment": "Staff of the Arcane, robes of the enlightened, spellbook, and a pouch of spell components",
  "treasure": "A crystal orb said to have been touched by the first wizards",
  "custom_equipment": "Silver circlet that enhances focus",
  "custom_treasure": "A shard from the Mirror of Fates",
  "spellcasting_class": "Wizard",
  "spellcasting_ability": "Intelligence",
  "spell_save_dc": "16",
  "spell_attack_bonus": "+8"
} 
    ]
    messages=[
        {"role": "system", "content": "You are a helpful dungeon master's assistant. You are helping a user fill in their D&D character sheet."},
        {"role": "system", "content": f"Here are some example character sheets:\n\n{examples}"},
        {"role": "system", "content": "The user will provide a JSON character sheet."},
        {"role": "user", "content": f"{json.dumps(character)}"},
        {"role": "system", "content": "Please completely fill in the JSON data for the character sheet based on the provided character sheet. Use proper JSON formatting for your response.  Don't leave any values blank."},
    ]
    print(f"Messages: {messages}")
    response = openai.ChatCompletion.create(model="gpt-3.5-turbo", messages=messages, max_tokens=MAX_TOKENS)
    #import ipdb; ipdb.set_trace()
    result = response.choices[0].message.content
    print(f"Result: {result}")
    return result

def save_dalle_image_to_disk(image_url, character_name, portrait_num):
    """
    Saves the DALLÂ·E generated image to the local disk.

    Args:
    - image_url (str): URL of the image generated by DALLÂ·E.
    - character_name (str): Name of the character to be used in filename.
    - portrait_num (int): The number of the portrait for this character.

    Returns:
    - str: The path to the saved file.
    """
    response = requests.get(image_url)
    response.raise_for_status()  # Raise an error for failed requests
    
    filename = f"{IMAGE_DIRECTORY}{character_name}_portrait_{portrait_num}.png"
    with open(filename, "wb") as file:
        file.write(response.content)
    return filename

def generate_portrait(prompt):
    """
    Generate a portrait based on the prompt using DALL-E and save it locally.
    
    Args:
    - prompt (str): The prompt for DALL-E to generate an image.

    Returns:
    - str: Filepath where the portrait is saved.
    """
    response = openai.Image.create(prompt=prompt, n=1, size="256x256")
    image_url = response.data[0]['url']
    filename = f"{uuid4()}.png"
    return save_dalle_image_to_disk(image_url, filename, 1)

def generate_html_character_sheet(character, portrait_filenames):
    """
    Generate an HTML character sheet based on character data and save it locally.

    Args:
    - character (dict): Dictionary containing character attributes.
    - portrait_filenames (list): List of portrait filenames for the character.

    Returns:
    - str: The path to the saved HTML file.
    """
    html_content = f"""
    <h1>{character['name']}</h1>
    <p><strong>Race:</strong> {character['race']}</p>
    <!-- ... Other attributes ... -->
    """
    for filename in portrait_filenames:
        html_content += f'<img src="{filename}" alt="Portrait of {character["name"]}">'
    
    filename = f"{CHARACTER_SHEET_DIRECTORY}{uuid4()}.html"
    with open(filename, 'w') as file:
       file.write(html_content)
    return filename

def input_basic_information(character_data):
    """
    Gather basic information about the character from the user.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing basic character information.
    """
    with st.expander("Basic Information"):
        race_options = ["Human", "Elf", "Dwarf", "Orc", "Tiefling", "Gnome", "Halfling", "Dragonborn", "Aarakocra", "Genasi", "Goliath", "Tabaxi", "Triton", "Custom"]
        class_options = ["Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", "Ranger", "Rogue", "Sorcerer", "Warlock", "Wizard", "Custom"]
        alignment_options = ["Lawful Good", "Neutral Good", "Chaotic Good", "Lawful Neutral", "True Neutral", "Chaotic Neutral", "Lawful Evil", "Neutral Evil", "Chaotic Evil"]
        background_options = ["Acolyte", "Charlatan", "Criminal", "Entertainer", "Folk Hero", "Guild Artisan", "Hermit", "Noble", "Outlander", "Sage", "Sailor", "Soldier", "Urchin", "Custom"]
        
        race = st.selectbox("Race", race_options)
        if race == "Custom":
            race = st.text_input("Custom Race", character_data.get("race", ""))
        
        char_class = st.selectbox("Class", class_options)
        if char_class == "Custom":
            char_class = st.text_input("Custom Class", character_data.get("class", ""))
        
        alignment = st.selectbox("Alignment", alignment_options)
        background = st.selectbox("Background", background_options)
        if background == "Custom":
            background = st.text_input("Custom Background", character_data.get("background", ""))
        
        return {
            "age": st.number_input("Age", min_value=1, max_value=500, step=1, value=int(character_data.get("age", 25) or "25")),
            "race": race,
            "class": char_class,
            "alignment": alignment,
            "background": background
        }

        

def input_personality_and_backstory(character_data):
    """
    Gather information about the character's personality and backstory.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's personality and backstory.
    """
    with st.expander("Personality & Backstory"):
        return {
            "personality_traits": st.text_area("Personality Traits", character_data.get("personality_traits", "")),
            "ideals": st.text_area("Ideals", character_data.get("ideals", "")),
            "bonds": st.text_area("Bonds", character_data.get("bonds", "")),
            "flaws": st.text_area("Flaws", character_data.get("flaws", "")),
            "character_backstory": st.text_area("Character Backstory", character_data.get("character_backstory", "")),
            "allies_enemies": st.text_area("Allies & Enemies", character_data.get("allies_enemies", ""))
        }

def input_abilities_and_skills(character_data):
    """
    Gather information about the character's abilities and skills.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's abilities and skills.
    """
    with st.expander("Abilities & Skills"):
        languages_options = ["Common", "Dwarvish", "Elvish", "Giant", "Gnomish", "Goblin", "Halfling", "Orc", 
                             "Abyssal", "Celestial", "Draconic", "Deep Speech", "Infernal", "Primordial", 
                             "Sylvan", "Undercommon", "Custom"]
        
        languages = st.multiselect("Languages", languages_options, default=character_data.get("languages", []))
        if "Custom" in languages:
            custom_language = st.text_input("Specify the custom language", character_data.get("custom_language", ""))
            languages.append(custom_language)
            languages.remove("Custom")

        skills_options = ["Acrobatics", "Animal Handling", "Arcana", "Athletics", "Deception", "History", 
                          "Insight", "Intimidation", "Investigation", "Medicine", "Nature", "Perception", 
                          "Performance", "Persuasion", "Religion", "Sleight of Hand", "Stealth", "Survival", "Custom"]
        
        skills = st.multiselect("Skills", skills_options, default=character_data.get("skills", []))
        if "Custom" in skills:
            custom_skill = st.text_input("Specify the custom skill", character_data.get("custom_skill", ""))
            skills.append(custom_skill)
            skills.remove("Custom")
        
        return {
            "languages": languages,
            "skills": skills,
            "custom_language": custom_language if "Custom" in character_data.get("languages", []) else "",
            "custom_skill": custom_skill if "Custom" in character_data.get("skills", []) else ""
        }

def input_equipment_and_treasures(character_data):
    """
    Gather information about the character's equipment and treasures.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's equipment and treasures.
    """
    with st.expander("Equipment & Treasures"):
        return {
            "equipment": st.text_area("Starting Equipment", character_data.get("equipment", "")),
            "treasure": st.text_area("Treasure", character_data.get("treasure", "")),
            "custom_equipment": st.text_input("Custom Equipment (if any)", character_data.get("custom_equipment", "")),
            "custom_treasure": st.text_input("Custom Treasure (if any)", character_data.get("custom_treasure", ""))
        }

def input_spellcasting(character_data):
    """
    Gather information about the character's spellcasting abilities.
    
    Args:
    - character_data (dict): Dictionary containing current character information.

    Returns:
    - dict: Dictionary containing character's spellcasting information.
    """
    with st.expander("Spellcasting"):
        spellcasting_class_options = ["Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", 
                                      "Ranger", "Rogue", "Sorcerer", "Warlock", "Wizard", "Custom"]
        
        spellcasting_class = st.selectbox("Spellcasting Class", spellcasting_class_options, index=spellcasting_class_options.index(character_data.get("spellcasting_class", "Barbarian")))
        if spellcasting_class == "Custom":
            spellcasting_class = st.text_input("Specify the custom spellcasting class", character_data.get("custom_spellcasting_class", ""))
        
        return {
            "spellcasting_class": spellcasting_class,
            "spellcasting_ability": st.text_input("Spellcasting Ability", character_data.get("spellcasting_ability", "")),
            "spell_save_dc": st.text_input("Spell Save DC", character_data.get("spell_save_dc", "")),
            "spell_attack_bonus": st.text_input("Spell Attack Bonus", character_data.get("spell_attack_bonus", ""))
        }

def generate_and_display_character_sheet(character):
    """
    Generate the character sheet, save the data, and display it to the user.
    
    Args:
    - character (dict): Dictionary containing all character attributes.
    """
    if st.button("Generate Character Sheet"):
        # Fetch filled out character data from the API
        character["description"] = get_character_data(character)

        # Generate portrait prompts and portraits
        num_portraits = st.slider("Number of Portraits", 1, 5)
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({
                key: character[key] for key in ["name", "race", "class", "background"]
            })
            portrait_filenames.append(generate_portrait(portrait_prompt))

        # Generate HTML character sheet and save
        html_filename = generate_html_character_sheet(character, portrait_filenames)

        # Save character data as parquet
        df = pd.DataFrame([character])
        parquet_filename = f"{DATA_DIRECTORY}{uuid4()}.parquet"
        df.to_parquet(parquet_filename)

        # Display the information to the user
        st.write(f"Character sheet saved at {html_filename} and data saved at {parquet_filename}")
        st.markdown(f"[Click here to view the character sheet]({html_filename})")

        # Render the HTML character sheet
        with open(html_filename, 'r') as file:
            st.components.v1.html(file.read(), height=1000)

def transform_to_dict(data_str):
    """
    Transform the provided data string into a dictionary.

    Args:
    - data_str (str): The string containing "key: value" pairs separated by newlines.

    Returns:
    - dict: The transformed dictionary.
    """
    print(f"Data string: {data_str}")
    #import ipdb; ipdb.set_trace()
    data_dict = json.loads(data_str)  # Convert the string to a dictionary
    return data_dict

def main():
    """
    Main function for the Streamlit app.
    """
    st.set_page_config(page_title="D&D Character Creator", page_icon="ðŸ“ˆ")
    st.markdown("# D&D Character Creator")
    
    character = {}

    # Initialize user input dictionary
    user_input_character = {
        "name": st.text_input("Character Name", ""),
        "description": st.text_area("Description", "")
    }

    # Use the user's input for the other sections
    user_input_character.update(input_basic_information(user_input_character))
    user_input_character.update(input_personality_and_backstory(user_input_character))
    user_input_character.update(input_abilities_and_skills(user_input_character))
    user_input_character.update(input_equipment_and_treasures(user_input_character))
    user_input_character.update(input_spellcasting(user_input_character))

    #import ipdb; ipdb.set_trace()
    character.update(user_input_character)

    # Check if user wants to generate a character sheet
    if st.button("Generate Character Sheet"):
        # Fetch filled out character data from the API
        generated_data = get_character_data(character)
        character_data = transform_to_dict(generated_data)
        character.update(character_data)

        print(f"Character: {character}")

        # Update all the user input fields with the generated data
        for key in character:
            if key in user_input_character:
                user_input_character[key] = character[key]

        # Refresh the Streamlit app to display the updated character data
        st.experimental_rerun()

    # Check if user wants to save the character sheet and portraits
    if st.button("Save Character and Portraits"):
        # Generate portrait prompts and portraits
        num_portraits = st.slider("Number of Portraits", 1, 5)
        portrait_filenames = []
        for _ in range(num_portraits):
            portrait_prompt = get_character_data({
                key: character[key] for key in ["name", "race", "class", "background"]
            })
            portrait_filenames.append(generate_portrait(portrait_prompt))

        # Generate HTML character sheet and save
        html_filename = generate_html_character_sheet(character, portrait_filenames)

        # Save character data as parquet
        df = pd.DataFrame([character])
        parquet_filename = f"{DATA_DIRECTORY}{uuid4()}.parquet"
        df.to_parquet(parquet_filename)

        # Display the saved locations to the user
        st.write(f"Character sheet saved at {html_filename} and data saved at {parquet_filename}")
        st.markdown(f"[Click here to view the character sheet]({html_filename})")

if __name__ == "__main__":
    main()
